import * as THREE from 'three';
import { PlayerConfig, PlayerInput, BodyVariant, OutfitType } from '../types';
import { SoundManager } from './SoundManager';

const SCALE_FACTOR = 1.0;

export class Player {
    scene: THREE.Scene;
    draggedPartName: string;
    moveSpeed: number;
    turnSpeed: number;
    walkTime: number;
    pickUpTime: number;
    isPickingUp: boolean;
    isDead: boolean;
    deathTime: number;
    wasDeadKeyPressed: boolean;
    isJumping: boolean;
    isLedgeGrabbing: boolean;
    isDragged: boolean;
    dragTarget: THREE.Vector3;
    dragVelocity: THREE.Vector3;
    ledgeGrabTime: number;
    ledgeTargetPos: THREE.Vector3;
    recoverTimer: number;
    jumpPhase: 'none' | 'anticipation' | 'airborne';
    jumpTimer: number;
    jumpVelocity: number;
    gravity: number;
    jumpPower: number;
    deathVariation: { side: number; twist: number; fallDir: number; stumbleDir: number };
    config: PlayerConfig;
    tempBox: THREE.Box3;
    
    // Animation States
    isInteracting: boolean = false;
    interactTimer: number = 0;
    isAxeSwing: boolean = false;
    axeSwingTimer: number = 0;
    isPunch: boolean = false;
    punchTimer: number = 0;

    // Helpers
    _tempVec1 = new THREE.Vector3();
    _tempVec2 = new THREE.Vector3();
    _tempQuat = new THREE.Quaternion();
    _localDown = new THREE.Vector3(0, -1, 0);
    
    // Inventory & Sound
    inventory: string[];
    inventoryCapacity: number;
    inventoryDirty: boolean;
    soundManager: SoundManager;

    // Mesh parts
    mesh!: THREE.Group;
    
    // Materials (Dynamic based on Outfit)
    skinMaterial!: THREE.MeshToonMaterial;
    shirtMaterial!: THREE.MeshToonMaterial; // Torso, Upper Arms
    pantsMaterial!: THREE.MeshToonMaterial; // Hips, Thighs, Shins
    bootsMaterial!: THREE.MeshToonMaterial; // Feet
    irisMaterial!: THREE.MeshToonMaterial;
    scleraMaterial!: THREE.MeshToonMaterial;
    pupilMaterial!: THREE.MeshToonMaterial;
    lipMaterial!: THREE.MeshToonMaterial;
    
    // Geometry Groups
    forefootGroups!: THREE.Group[];
    heelGroups!: THREE.Group[];
    toeUnits!: THREE.Group[];
    
    // Eyes parts for scaling
    irises: THREE.Mesh[] = [];
    pupils: THREE.Mesh[] = [];

    // Skeleton Structure
    hips!: THREE.Group;
    torsoContainer!: THREE.Group;
    torso!: THREE.Mesh;
    torsoOutline!: THREE.Mesh;
    neck!: THREE.Mesh;
    head!: THREE.Mesh;
    jaw!: THREE.Group;
    jawMesh!: THREE.Mesh;
    jawOutline!: THREE.Mesh;
    
    // Torso Details
    topCap!: THREE.Mesh;
    botCap!: THREE.Mesh;
    topCapOutline!: THREE.Mesh;
    botCapOutline!: THREE.Mesh;
    chest!: THREE.Group;
    
    faceGroup!: THREE.Group;
    nose!: THREE.Group;
    rightThigh!: THREE.Group;
    rightShin!: THREE.Group;
    leftThigh!: THREE.Group;
    leftShin!: THREE.Group;
    
    rightArm!: THREE.Group;
    rightForeArm!: THREE.Group;
    leftArm!: THREE.Group;
    leftForeArm!: THREE.Group;
    rightHand!: THREE.Group;
    leftHand!: THREE.Group;

    // Mount Points for Equipment
    headMount!: THREE.Group;
    leftShoulderMount!: THREE.Group;
    rightShoulderMount!: THREE.Group;
    leftShieldMount!: THREE.Group;

    // Equipment Meshes
    equippedMeshes: {
        helm?: THREE.Object3D;
        leftPauldron?: THREE.Object3D;
        rightPauldron?: THREE.Object3D;
        shield?: THREE.Object3D;
    } = {};

    // State Tracking
    private lastBodyType: 'male' | 'female' = 'male';
    // Removed lastVariant tracking as logic is now lifted to React state
    private lastOutfit: OutfitType | null = null;
    private lastEquipmentState: string = "";

    constructor(scene: THREE.Scene) {
        this.scene = scene;
        this.draggedPartName = 'hips';
        this.moveSpeed = 5;
        this.turnSpeed = 10;
        this.walkTime = 0;
        this.pickUpTime = 0;
        this.isPickingUp = false;
        this.isDead = false;
        this.deathTime = 0;
        this.wasDeadKeyPressed = false;
        this.isJumping = false;
        this.isLedgeGrabbing = false;
        this.isDragged = false;
        this.dragTarget = new THREE.Vector3();
        this.dragVelocity = new THREE.Vector3();
        this.ledgeGrabTime = 0;
        this.ledgeTargetPos = new THREE.Vector3();
        this.recoverTimer = 0;
        this.jumpPhase = 'none'; // 'none', 'anticipation', 'airborne'
        this.jumpTimer = 0;
        this.jumpVelocity = 0;
        this.gravity = -30;
        this.jumpPower = 11;
        this.deathVariation = { side: 1, twist: 0, fallDir: 1, stumbleDir: 0 };
        
        this.inventory = [];
        this.inventoryCapacity = 5;
        this.inventoryDirty = false;
        this.soundManager = new SoundManager();

        // Default Config will be overwritten by React props immediately, 
        // but setting good defaults here ensures safe mesh creation.
        this.config = {
            bodyType: 'male',
            bodyVariant: 'average',
            outfit: 'naked',
            equipment: { helm: false, shoulders: false, shield: false },
            skinColor: '#ffdbac',
            eyeColor: '#333333',
            scleraColor: '#ffffff',
            pupilColor: '#000000',
            lipColor: '#e0b094',
            headScale: 1.0,
            torsoWidth: 1.0,
            torsoHeight: 1.0,
            armScale: 1.0,
            legScale: 1.0,
            heelScale: 1.218,
            heelHeight: 1.0,
            toeScale: 1.0,
            footLength: 1.0,
            footWidth: 1.0,
            toeSpread: 1.0,
            chinSize: 0.7,
            chinLength: 1.0,
            chinForward: 0.03,
            chinHeight: -0.04,
            irisScale: 1.0,
            pupilScale: 1.0,
        };

        this.tempBox = new THREE.Box3();
        this.createMesh();
    }

    get runMultiplier() {
        return 1.8;
    }

    addItem(itemName: string): boolean {
        if (this.inventory.length >= this.inventoryCapacity) {
            return false;
        }
        this.inventory.push(itemName);
        this.inventoryDirty = true;
        return true;
    }

    removeItem(index: number) {
        if (index >= 0 && index < this.inventory.length) {
            this.inventory.splice(index, 1);
            this.inventoryDirty = true;
        }
    }

    playInteract() {
        if (!this.isInteracting) {
            this.isInteracting = true;
            this.interactTimer = 0;
        }
    }

    playAxeSwing() {
        if (!this.isAxeSwing) {
            this.isAxeSwing = true;
            this.axeSwingTimer = 0;
        }
    }

    playPunch() {
        if (!this.isPunch) {
            this.isPunch = true;
            this.punchTimer = 0;
        }
    }

    createMesh() {
        this.mesh = new THREE.Group();
        this.mesh.castShadow = true;

        // --- Materials ---
        const outlineColor = 0x000000;

        // Base Materials - Colors will be set in updateOutfit()
        this.skinMaterial = new THREE.MeshToonMaterial({ color: this.config.skinColor });
        this.shirtMaterial = new THREE.MeshToonMaterial({ color: 0x888888 }); 
        this.pantsMaterial = new THREE.MeshToonMaterial({ color: 0x444444 });
        this.bootsMaterial = new THREE.MeshToonMaterial({ color: 0x222222 });
        this.lipMaterial = new THREE.MeshToonMaterial({ color: this.config.lipColor });
        
        // Outline material
        const outlineMaterial = new THREE.MeshBasicMaterial({ 
            color: outlineColor, 
            side: THREE.BackSide 
        });

        this.forefootGroups = [];
        this.heelGroups = [];
        this.toeUnits = [];

        // --- Feet Creation Logic ---
        const createFootParts = (isLeftFoot: boolean) => {
            // Feet always use bootsMaterial (or skin if naked)
            const footMat = this.bootsMaterial;
            
            const footY = -0.06;
            const rBack = 0.08, len = 0.22;
            const heelZ = 0.08 - len/2;
            const heelPos = new THREE.Vector3(0, footY, heelZ);

            // 1. Heel Part
            const heelGroup = new THREE.Group();
            heelGroup.position.copy(heelPos);
            heelGroup.position.y += 0.05; 
            
            const heelGeo = new THREE.CylinderGeometry(rBack * 0.7, rBack, rBack * 1.8, 6);
            const heelMesh = new THREE.Mesh(heelGeo, footMat);
            heelMesh.rotation.x = 0.1; 
            heelMesh.castShadow = true;
            heelGroup.add(heelMesh);

            const heelOutline = new THREE.Mesh(heelGeo, outlineMaterial);
            heelOutline.rotation.copy(heelMesh.rotation);
            heelOutline.scale.setScalar(1.1);
            heelGroup.add(heelOutline);
            
            this.heelGroups.push(heelGroup);

            // 2. Forefoot Part
            const forefootGroup = new THREE.Group();
            forefootGroup.position.copy(heelPos);

            const toeR = 0.022, toeL = 0.05;
            const toeGeo = new THREE.CapsuleGeometry(toeR, toeL, 4, 8);
            const baseDepth = 0.08 + len/2;

            for (let i = 0; i < 5; i++) {
                const xPos = (i - 2) * 0.035; 
                const zCurve = -Math.abs(i - 2) * 0.012 + 0.03;
                const worldToePos = new THREE.Vector3(xPos, footY - 0.015, baseDepth + zCurve);
                const localToePos = new THREE.Vector3().subVectors(worldToePos, heelPos);
                
                const toeUnit = new THREE.Group();
                toeUnit.position.x = localToePos.x;
                forefootGroup.add(toeUnit);
                this.toeUnits.push(toeUnit);

                const toe = new THREE.Mesh(toeGeo, footMat);
                toe.position.set(0, localToePos.y, localToePos.z);
                toe.rotation.x = Math.PI / 2 + 0.1;
                toe.rotation.y = (i - 2) * 0.12; 
                toe.castShadow = true;
                toeUnit.add(toe);

                const toeOutline = new THREE.Mesh(toeGeo, outlineMaterial);
                toeOutline.position.copy(toe.position);
                toeOutline.rotation.copy(toe.rotation);
                toeOutline.scale.setScalar(1.2);
                toeUnit.add(toeOutline);

                const bridgeStart = new THREE.Vector3(localToePos.x * 0.6, 0, 0); 
                const bridgeVec = new THREE.Vector3().subVectors(localToePos, bridgeStart);
                const bridgeLen = bridgeVec.length();
                
                const bridgeGeo = new THREE.CylinderGeometry(toeR * 1.1, rBack * 0.8, bridgeLen, 8);
                const bridge = new THREE.Mesh(bridgeGeo, footMat);
                
                const mid = new THREE.Vector3().addVectors(bridgeStart, localToePos).multiplyScalar(0.5);
                bridge.position.copy(mid);
                bridge.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), bridgeVec.clone().normalize());
                bridge.castShadow = true;
                forefootGroup.add(bridge);

                const bridgeOutline = new THREE.Mesh(bridgeGeo, outlineMaterial);
                bridgeOutline.position.copy(bridge.position);
                bridgeOutline.quaternion.copy(bridge.quaternion);
                bridgeOutline.scale.set(1.2, 1.0, 1.2);
                forefootGroup.add(bridgeOutline);
            }

            this.forefootGroups.push(forefootGroup);
            return { heelGroup, forefootGroup };
        };

        // Create a limb segment
        const createSegment = (radius: number, length: number, segMaterial: THREE.Material, radiusBottom: number = radius) => {
            const container = new THREE.Group();
            
            const topJointGeo = new THREE.SphereGeometry(radius, 12, 12);
            const topJoint = new THREE.Mesh(topJointGeo, segMaterial);
            topJoint.castShadow = true;
            container.add(topJoint);

            const topJointOutline = new THREE.Mesh(topJointGeo, outlineMaterial);
            topJointOutline.scale.setScalar(1.1);
            container.add(topJointOutline);

            const geo = new THREE.CylinderGeometry(radius, radiusBottom, length, 12, 1);
            const mesh = new THREE.Mesh(geo, segMaterial);
            mesh.position.y = -length / 2;
            mesh.castShadow = true;
            container.add(mesh);

            const outline = new THREE.Mesh(geo, outlineMaterial);
            outline.position.copy(mesh.position);
            outline.scale.setScalar(1.1);
            container.add(outline);

            const botJointGeo = new THREE.SphereGeometry(radiusBottom, 12, 12);
            const botJoint = new THREE.Mesh(botJointGeo, segMaterial);
            botJoint.position.y = -length;
            botJoint.castShadow = true;
            container.add(botJoint);

            const botJointOutline = new THREE.Mesh(botJointGeo, outlineMaterial);
            botJointOutline.position.copy(botJoint.position);
            botJointOutline.scale.setScalar(1.1);
            container.add(botJointOutline);

            return container;
        };

        // --- Structure ---
        
        // Hips
        this.hips = new THREE.Group();
        this.hips.position.y = 1.0; 
        this.mesh.add(this.hips);

        // Torso
        const torsoRadiusTop = 0.28;
        const torsoRadiusBottom = 0.22;
        const torsoLen = 0.45;
        
        this.torsoContainer = new THREE.Group();
        this.hips.add(this.torsoContainer);

        const torsoGeo = new THREE.CylinderGeometry(torsoRadiusTop, torsoRadiusBottom, torsoLen, 16);
        this.torso = new THREE.Mesh(torsoGeo, this.shirtMaterial); // Shirt Material
        this.torso.position.y = torsoLen / 2 + 0.1; 
        this.torso.castShadow = true;
        this.torsoContainer.add(this.torso);

        const topCapGeo = new THREE.SphereGeometry(torsoRadiusTop, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        this.topCap = new THREE.Mesh(topCapGeo, this.shirtMaterial);
        this.topCap.position.y = torsoLen / 2;
        this.torso.add(this.topCap);
        
        const botCapGeo = new THREE.SphereGeometry(torsoRadiusBottom, 16, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2);
        this.botCap = new THREE.Mesh(botCapGeo, this.shirtMaterial);
        this.botCap.position.y = -torsoLen / 2;
        this.torso.add(this.botCap);

        // Torso Outlines
        this.torsoOutline = new THREE.Mesh(torsoGeo, outlineMaterial);
        this.torsoOutline.scale.setScalar(1.05);
        this.torso.add(this.torsoOutline);

        this.topCapOutline = new THREE.Mesh(topCapGeo, outlineMaterial);
        this.topCapOutline.position.y = torsoLen / 2;
        this.topCapOutline.scale.setScalar(1.05);
        this.torso.add(this.topCapOutline);

        this.botCapOutline = new THREE.Mesh(botCapGeo, outlineMaterial);
        this.botCapOutline.position.y = -torsoLen / 2;
        this.botCapOutline.scale.setScalar(1.05);
        this.torso.add(this.botCapOutline);

        // Chest (Female)
        this.chest = new THREE.Group();
        this.chest.visible = false; 
        this.chest.position.set(0, 0.1, 0.18);
        this.torso.add(this.chest);

        const chestRadius = 0.13;
        const chestGeo = new THREE.SphereGeometry(chestRadius, 16, 16);
        
        const leftBreast = new THREE.Mesh(chestGeo, this.shirtMaterial);
        leftBreast.position.x = 0.11;
        leftBreast.scale.set(1, 0.9, 0.8);
        leftBreast.castShadow = true;
        this.chest.add(leftBreast);
        
        const leftBreastOutline = new THREE.Mesh(chestGeo, outlineMaterial);
        leftBreastOutline.position.copy(leftBreast.position);
        leftBreastOutline.scale.copy(leftBreast.scale).multiplyScalar(1.05);
        leftBreastOutline.position.z -= 0.01;
        this.chest.add(leftBreastOutline);

        const rightBreast = new THREE.Mesh(chestGeo, this.shirtMaterial);
        rightBreast.position.x = -0.11;
        rightBreast.scale.set(1, 0.9, 0.8);
        rightBreast.castShadow = true;
        this.chest.add(rightBreast);

        const rightBreastOutline = new THREE.Mesh(chestGeo, outlineMaterial);
        rightBreastOutline.position.copy(rightBreast.position);
        rightBreastOutline.scale.copy(rightBreast.scale).multiplyScalar(1.05);
        rightBreastOutline.position.z -= 0.01;
        this.chest.add(rightBreastOutline);

        // Neck
        const neckRadius = 0.08;
        const neckLen = 0.2;
        const neckGeo = new THREE.CapsuleGeometry(neckRadius, neckLen, 4, 8);
        this.neck = new THREE.Mesh(neckGeo, this.skinMaterial); // Skin
        this.neck.position.y = torsoLen + 0.3;
        this.neck.castShadow = true;
        this.hips.add(this.neck);

        const neckOutline = new THREE.Mesh(neckGeo, outlineMaterial);
        neckOutline.position.copy(this.neck.position);
        neckOutline.scale.setScalar(1.1);
        this.hips.add(neckOutline);

        // Head
        const headRadius = 0.21;
        const headGeo = new THREE.SphereGeometry(headRadius, 64, 64);
        const posAttribute = headGeo.attributes.position;
        const vertex = new THREE.Vector3();
        const leftEyeCenter = new THREE.Vector3(0.09, -0.015, headRadius * 0.92);
        const rightEyeCenter = new THREE.Vector3(-0.09, -0.015, headRadius * 0.92);
        const socketRad = 0.065;
        const socketDep = 0.025;

        for (let i = 0; i < posAttribute.count; i++) {
            vertex.fromBufferAttribute(posAttribute, i);
            if (vertex.z > 0 && Math.abs(vertex.x) < 0.18) vertex.z *= 0.94; 
            if (vertex.z > 0 && Math.abs(vertex.x) > 0.15) vertex.x *= 0.95; 
            if (vertex.y < -0.04 && vertex.z > 0) {
                vertex.x *= 0.88;
                if (vertex.y < -headRadius * 0.65) {
                     if (Math.abs(vertex.x) < 0.08) vertex.z += 0.008;
                     vertex.y *= 0.95;
                }
            }
            const distL = vertex.distanceTo(leftEyeCenter);
            const distR = vertex.distanceTo(rightEyeCenter);
            if (distL < socketRad) {
                const f = Math.cos((distL / socketRad) * Math.PI * 0.5); 
                vertex.z -= f * socketDep;
                vertex.y += f * 0.012; 
            }
            if (distR < socketRad) {
                const f = Math.cos((distR / socketRad) * Math.PI * 0.5);
                vertex.z -= f * socketDep;
                vertex.y += f * 0.012;
            }
            const browY = 0.045;
            if (Math.abs(vertex.y - browY) < 0.04 && vertex.z > 0.1) {
                if (Math.abs(vertex.x) > 0.03 && Math.abs(vertex.x) < 0.14) {
                     vertex.z += 0.005 * Math.cos(Math.abs(vertex.y - browY) * 20);
                }
            }
            posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
        }
        
        headGeo.computeVertexNormals();

        this.head = new THREE.Mesh(headGeo, this.skinMaterial); // Skin
        this.head.position.y = this.neck.position.y + neckLen/2 + headRadius + 0.01;
        this.head.castShadow = true;
        this.hips.add(this.head);

        // HEAD MOUNT POINT
        this.headMount = new THREE.Group();
        this.head.add(this.headMount);

        const headOutline = new THREE.Mesh(headGeo, outlineMaterial);
        headOutline.position.copy(this.head.position);
        headOutline.scale.setScalar(1.05); 
        headOutline.position.z -= 0.002;
        this.hips.add(headOutline);

        // Jaw
        this.jaw = new THREE.Group();
        this.jaw.position.set(0, -0.05, 0.02); 
        this.head.add(this.jaw);

        const jawGeo = new THREE.SphereGeometry(0.12, 16, 16);
        this.jawMesh = new THREE.Mesh(jawGeo, this.skinMaterial); // Skin
        this.jawMesh.scale.set(0.7, 0.45, 0.85);
        this.jawMesh.position.set(0, -0.105, 0.09); 
        this.jawMesh.rotation.x = 0.15;
        this.jawMesh.castShadow = true;
        this.jaw.add(this.jawMesh);

        this.jawOutline = new THREE.Mesh(jawGeo, outlineMaterial);
        this.jawOutline.scale.copy(this.jawMesh.scale).multiplyScalar(1.05);
        this.jawOutline.position.copy(this.jawMesh.position);
        this.jawOutline.rotation.copy(this.jawMesh.rotation);
        this.jaw.add(this.jawOutline);

        // Facial Features
        this.faceGroup = new THREE.Group();
        this.head.add(this.faceGroup);

        const eyeRadius = 0.045;
        const eyeGeo = new THREE.SphereGeometry(eyeRadius, 32, 32);
        
        // Define materials for eyes
        this.scleraMaterial = new THREE.MeshToonMaterial({ color: this.config.scleraColor });
        this.irisMaterial = new THREE.MeshToonMaterial({ color: this.config.eyeColor });
        this.pupilMaterial = new THREE.MeshToonMaterial({ color: this.config.pupilColor });
        const highlightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eyeZPos = 0.162;

        this.irises = [];
        this.pupils = [];

        for (let side of [-1, 1]) {
            const eyeContainer = new THREE.Group();
            eyeContainer.position.set(side * 0.09, -0.02, eyeZPos);
            this.faceGroup.add(eyeContainer);

            const eyeball = new THREE.Mesh(eyeGeo, this.scleraMaterial);
            eyeball.scale.set(1.1, 1, 0.8);
            eyeContainer.add(eyeball);

            // Positioning Iris: 
            // Eyeball radius is eyeRadius. Surface is at z = eyeRadius in geometry space.
            // Since eyeball mesh is scaled Z by 0.8, visual surface is at 0.8*eyeRadius.
            // Putting Iris at eyeRadius * 1.02 ensures it sits slightly outside the geometry sphere 
            // (but effectively on surface after scaling and flattening).
            const irisGeo = new THREE.CircleGeometry(eyeRadius * 0.65, 16);
            const iris = new THREE.Mesh(irisGeo, this.irisMaterial);
            iris.position.z = eyeRadius * 1.02;
            eyeball.add(iris);
            this.irises.push(iris);

            const pupilGeo = new THREE.CircleGeometry(eyeRadius * 0.25, 16);
            const pupil = new THREE.Mesh(pupilGeo, this.pupilMaterial);
            pupil.position.z = 0.002; // Small offset from Iris to avoid Z-fighting
            iris.add(pupil);
            this.pupils.push(pupil);

            const highlightGeo = new THREE.SphereGeometry(eyeRadius * 0.15, 8, 8);
            const highlight = new THREE.Mesh(highlightGeo, highlightMat);
            highlight.position.set(eyeRadius * 0.2, eyeRadius * 0.2, 0.01);
            iris.add(highlight);

            const lidGeo = new THREE.TorusGeometry(eyeRadius * 1.05, 0.008, 8, 16, Math.PI * 0.8);
            const lid = new THREE.Mesh(lidGeo, outlineMaterial);
            lid.position.z = 0.01;
            lid.rotation.z = Math.PI * 0.1;
            eyeContainer.add(lid);
        }

        this.nose = new THREE.Group();
        this.nose.position.set(0, -0.06, 0.198); 
        this.faceGroup.add(this.nose);

        const bridgeGeo = new THREE.CylinderGeometry(0.015, 0.025, 0.06, 8);
        const bridge = new THREE.Mesh(bridgeGeo, this.skinMaterial); // Skin
        bridge.rotation.x = -0.4;
        bridge.position.y = 0.02;
        this.nose.add(bridge);
        const bridgeO = new THREE.Mesh(bridgeGeo, outlineMaterial);
        bridgeO.scale.setScalar(1.2);
        bridge.add(bridgeO);

        const tipGeo = new THREE.SphereGeometry(0.022, 12, 12);
        const tip = new THREE.Mesh(tipGeo, this.skinMaterial); // Skin
        tip.position.set(0, -0.01, 0.02);
        this.nose.add(tip);
        const tipO = new THREE.Mesh(tipGeo, outlineMaterial);
        tipO.scale.setScalar(1.15);
        tip.add(tipO);

        const alaGeo = new THREE.SphereGeometry(0.015, 8, 8);
        for (let side of [-1, 1]) {
            const ala = new THREE.Mesh(alaGeo, this.skinMaterial); // Skin
            ala.position.set(side * 0.02, -0.015, 0.01);
            ala.scale.set(1.2, 0.8, 1);
            this.nose.add(ala);
            const alaO = new THREE.Mesh(alaGeo, outlineMaterial);
            alaO.scale.setScalar(1.15);
            ala.add(alaO);
        }
        
        // --- Lips ---
        // We create lips using TubeGeometry along a curve to get a "Cupid's bow" shape.
        // To avoid "sausages", we scale them flat on the Z axis and bury them slightly in the face.
        const mouthGroup = new THREE.Group();
        mouthGroup.position.set(0, -0.105, 0.19); // Positioned between nose and chin
        this.faceGroup.add(mouthGroup);
        
        // Upper Lip Path (Cupid's Bow shape: start, mid-peak, center-dip, mid-peak, end)
        const upperCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-0.035, -0.002, 0),
            new THREE.Vector3(-0.015, 0.008, 0.005),
            new THREE.Vector3(0, 0.004, 0.005), // Center dip
            new THREE.Vector3(0.015, 0.008, 0.005),
            new THREE.Vector3(0.035, -0.002, 0)
        ]);
        
        const upperLipGeo = new THREE.TubeGeometry(upperCurve, 20, 0.006, 8, false);
        const upperLip = new THREE.Mesh(upperLipGeo, this.lipMaterial);
        upperLip.scale.set(1, 1, 0.5); // Flatten Z
        upperLip.rotation.x = -0.2; // Angle slightly out
        upperLip.castShadow = true;
        mouthGroup.add(upperLip);

        // Lower Lip Path (Simple curve)
        const lowerCurve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-0.035, 0, 0),
            new THREE.Vector3(-0.015, -0.008, 0.005),
            new THREE.Vector3(0, -0.01, 0.008),
            new THREE.Vector3(0.015, -0.008, 0.005),
            new THREE.Vector3(0.035, 0, 0)
        ]);
        
        const lowerLipGeo = new THREE.TubeGeometry(lowerCurve, 20, 0.007, 8, false);
        const lowerLip = new THREE.Mesh(lowerLipGeo, this.lipMaterial);
        lowerLip.scale.set(1, 1, 0.5); // Flatten Z
        lowerLip.position.y = -0.005;
        lowerLip.castShadow = true;
        mouthGroup.add(lowerLip);

        // Limbs
        const limbRadius = 0.1;
        const thighLen = 0.4;
        const shinLen = 0.4;
        const armLen = 0.35;

        // Legs (Pants)
        this.rightThigh = createSegment(limbRadius, thighLen, this.pantsMaterial);
        this.rightThigh.position.set(-0.12, 0, 0); 
        this.hips.add(this.rightThigh);

        this.rightShin = createSegment(limbRadius, shinLen, this.pantsMaterial);
        this.rightShin.position.y = -thighLen;
        this.rightThigh.add(this.rightShin);

        this.leftThigh = createSegment(limbRadius, thighLen, this.pantsMaterial);
        this.leftThigh.position.set(0.12, 0, 0);
        this.hips.add(this.leftThigh);

        this.leftShin = createSegment(limbRadius, shinLen, this.pantsMaterial);
        this.leftShin.position.y = -thighLen;
        this.leftThigh.add(this.leftShin);

        const rParts = createFootParts(false);
        const lParts = createFootParts(true);

        const footOffsetY = -shinLen - 0.05;
        
        rParts.heelGroup.position.y += footOffsetY;
        rParts.forefootGroup.position.y += footOffsetY;
        this.rightShin.add(rParts.heelGroup);
        this.rightShin.add(rParts.forefootGroup);

        lParts.heelGroup.position.y += footOffsetY;
        lParts.forefootGroup.position.y += footOffsetY;
        this.leftShin.add(lParts.heelGroup);
        this.leftShin.add(lParts.forefootGroup);

        // Arms
        const shoulderY = torsoLen + 0.18;
        const shoulderX = 0.35;
        const foreArmLen = armLen * 0.5;

        // Right Arm (Shirt)
        this.rightArm = createSegment(limbRadius, armLen, this.shirtMaterial, 0.08);
        this.rightArm.position.set(-shoulderX, shoulderY, 0);
        this.hips.add(this.rightArm);
        
        // Right Shoulder Mount
        this.rightShoulderMount = new THREE.Group();
        this.rightShoulderMount.position.y = 0.05;
        this.rightArm.add(this.rightShoulderMount);

        // Right Forearm (Shirt? or Skin?) -> Usually shirt sleeves go to elbow or wrist. Let's make forearm shirt too for peasant/noble
        this.rightForeArm = createSegment(0.08, foreArmLen, this.shirtMaterial, 0.05);
        this.rightForeArm.position.y = -armLen;
        this.rightArm.add(this.rightForeArm);

        // Left Arm (Shirt)
        this.leftArm = createSegment(limbRadius, armLen, this.shirtMaterial, 0.08);
        this.leftArm.position.set(shoulderX, shoulderY, 0);
        this.hips.add(this.leftArm);

        // Left Shoulder Mount
        this.leftShoulderMount = new THREE.Group();
        this.leftShoulderMount.position.y = 0.05;
        this.leftArm.add(this.leftShoulderMount);

        this.leftForeArm = createSegment(0.08, foreArmLen, this.shirtMaterial, 0.05);
        this.leftForeArm.position.y = -armLen;
        this.leftArm.add(this.leftForeArm);
        
        // Shield Mount (Left Forearm)
        this.leftShieldMount = new THREE.Group();
        this.leftShieldMount.position.y = -foreArmLen * 0.5;
        this.leftShieldMount.rotation.y = Math.PI / 2; // Face outward
        this.leftShieldMount.position.x = 0.06; // Offset from arm surface
        this.leftForeArm.add(this.leftShieldMount);

        // Hands (Skin)
        const createHand = (isLeftHand: boolean) => {
            const hand = new THREE.Group();
            const handMat = this.skinMaterial;
            
            const pR = 0.055, pL = 0.04;
            const pGeo = new THREE.CapsuleGeometry(pR, pL, 4, 8);
            
            const palm = new THREE.Mesh(pGeo, handMat);
            palm.rotation.z = Math.PI / 2;
            palm.scale.set(1.5, 1, 1);
            palm.position.y = -0.06; 
            palm.castShadow = true;
            hand.add(palm);

            const palmOutline = new THREE.Mesh(pGeo, outlineMaterial);
            palmOutline.position.copy(palm.position);
            palmOutline.rotation.copy(palm.rotation);
            palmOutline.scale.set(1.5 * 1.15, 1.15, 1.15);
            hand.add(palmOutline);

            const fR = 0.02, fL = 0.05;
            const fGeo = new THREE.CapsuleGeometry(fR, fL, 4, 8);
            const fingerStartY = -0.14; 
            for(let i=0; i<4; i++) {
                const f = new THREE.Mesh(fGeo, handMat);
                f.position.set((i-1.5)*0.032, fingerStartY, 0);
                f.castShadow = true;
                hand.add(f);
                
                const fo = new THREE.Mesh(fGeo, outlineMaterial);
                fo.position.copy(f.position);
                fo.scale.setScalar(1.3);
                hand.add(fo);
            }
            
            const thumb = new THREE.Mesh(fGeo, handMat);
            const side = isLeftHand ? -1 : 1; 
            thumb.position.set(0.06 * side, -0.08, 0);
            thumb.rotation.z = -(Math.PI / 2) * side; 
            thumb.castShadow = true;
            hand.add(thumb);
            
            const to = new THREE.Mesh(fGeo, outlineMaterial);
            to.position.copy(thumb.position);
            to.rotation.copy(thumb.rotation);
            to.scale.setScalar(1.3);
            hand.add(to);

            return hand;
        };

        this.rightHand = createHand(false);
        this.rightHand.position.y = -foreArmLen;
        this.rightHand.rotation.y = -Math.PI / 2;
        this.rightForeArm.add(this.rightHand);

        this.leftHand = createHand(true);
        this.leftHand.position.y = -foreArmLen;
        this.leftHand.rotation.y = Math.PI / 2;
        this.leftForeArm.add(this.leftHand);

        this.mesh.rotation.y = Math.PI;
        this.scene.add(this.mesh);
    }

    applyOutfit(outfit: OutfitType) {
        let shirtColor = 0x888888;
        let pantsColor = 0x444444;
        let bootsColor = 0x222222;

        switch (outfit) {
            case 'naked':
                this.shirtMaterial.color.set(this.config.skinColor);
                this.pantsMaterial.color.set(this.config.skinColor);
                this.bootsMaterial.color.set(this.config.skinColor);
                return;
            case 'peasant':
                shirtColor = 0x8d6e63;
                pantsColor = 0x5d4037;
                bootsColor = 0x3e2723;
                break;
            case 'warrior':
                shirtColor = 0x607d8b;
                pantsColor = 0x37474f;
                bootsColor = 0x263238;
                break;
            case 'noble':
                shirtColor = 0x3f51b5;
                pantsColor = 0x1a237e;
                bootsColor = 0x111111;
                break;
        }

        this.shirtMaterial.color.setHex(shirtColor);
        this.pantsMaterial.color.setHex(pantsColor);
        this.bootsMaterial.color.setHex(bootsColor);
    }

    updateEquipment() {
        const { helm, shoulders, shield } = this.config.equipment;

        // Helm
        if (helm) {
            if (!this.equippedMeshes.helm) {
                const helmGroup = new THREE.Group();
                const helmGeo = new THREE.CylinderGeometry(0.23, 0.23, 0.15, 16);
                const helmMat = new THREE.MeshStandardMaterial({ color: 0x90a4ae, metalness: 0.6, roughness: 0.4 });
                const mesh = new THREE.Mesh(helmGeo, helmMat);
                mesh.position.y = 0.1;
                mesh.castShadow = true;
                helmGroup.add(mesh);
                
                const topGeo = new THREE.SphereGeometry(0.22, 16, 8, 0, Math.PI * 2, 0, Math.PI/2);
                const top = new THREE.Mesh(topGeo, helmMat);
                top.position.y = 0.15/2;
                helmGroup.add(top);

                this.headMount.add(helmGroup);
                this.equippedMeshes.helm = helmGroup;
            }
            this.equippedMeshes.helm.visible = true;
        } else {
            if (this.equippedMeshes.helm) this.equippedMeshes.helm.visible = false;
        }

        // Shoulders
        if (shoulders) {
            if (!this.equippedMeshes.leftPauldron) {
                const createPauldron = () => {
                    const group = new THREE.Group();
                    const geo = new THREE.SphereGeometry(0.14, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x90a4ae, metalness: 0.6, roughness: 0.4 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.scale.set(1, 0.8, 1);
                    mesh.castShadow = true;
                    group.add(mesh);
                    return group;
                };

                const leftP = createPauldron();
                this.leftShoulderMount.add(leftP);
                this.equippedMeshes.leftPauldron = leftP;

                const rightP = createPauldron();
                this.rightShoulderMount.add(rightP);
                this.equippedMeshes.rightPauldron = rightP;
            }
            this.equippedMeshes.leftPauldron.visible = true;
            this.equippedMeshes.rightPauldron.visible = true;
        } else {
            if (this.equippedMeshes.leftPauldron) this.equippedMeshes.leftPauldron.visible = false;
            if (this.equippedMeshes.rightPauldron) this.equippedMeshes.rightPauldron.visible = false;
        }

        // Shield
        if (shield) {
            if (!this.equippedMeshes.shield) {
                const shieldGroup = new THREE.Group();
                const shape = new THREE.Shape();
                shape.moveTo(0, 0.2);
                shape.lineTo(0.15, 0.15);
                shape.lineTo(0.12, -0.1);
                shape.quadraticCurveTo(0, -0.3, -0.12, -0.1);
                shape.lineTo(-0.15, 0.15);
                shape.lineTo(0, 0.2);
                
                const extrudeSettings = { depth: 0.03, bevelEnabled: true, bevelThickness: 0.01, bevelSize: 0.01, bevelSegments: 1 };
                const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const mat = new THREE.MeshStandardMaterial({ color: 0x5d4037, metalness: 0.1, roughness: 0.8 });
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x90a4ae, metalness: 0.6, roughness: 0.4 });
                
                const mesh = new THREE.Mesh(geo, mat);
                mesh.castShadow = true;
                shieldGroup.add(mesh);
                
                const rim = new THREE.Mesh(geo, rimMat);
                rim.scale.set(1.05, 1.05, 1.1);
                rim.position.z = -0.005;
                shieldGroup.add(rim);

                shieldGroup.rotation.x = -Math.PI / 2;
                shieldGroup.rotation.z = Math.PI / 2;

                this.leftShieldMount.add(shieldGroup);
                this.equippedMeshes.shield = shieldGroup;
            }
            this.equippedMeshes.shield.visible = true;
        } else {
            if (this.equippedMeshes.shield) this.equippedMeshes.shield.visible = false;
        }
    }

    updateConfig() {
         // Check for Outfit Change and apply materials
         if (this.lastOutfit !== this.config.outfit) {
             this.applyOutfit(this.config.outfit);
             this.lastOutfit = this.config.outfit;
         }

         // Check for Equipment Change
         const eqKey = JSON.stringify(this.config.equipment);
         if (this.lastEquipmentState !== eqKey) {
             this.updateEquipment();
             this.lastEquipmentState = eqKey;
         }

         // --- Apply Standard Transforms (Controlled by external config) ---
         this.head.scale.setScalar(this.config.headScale);
         // Jaw Configs
         this.jaw.scale.setScalar(this.config.chinSize);
         
         // Apply Chin Height (Vertical Position)
         this.jaw.position.y = -0.05 + this.config.chinHeight;

         const baseScaleY = 0.45;
         const basePosZ = 0.09;
         
         this.jawMesh.scale.y = baseScaleY * this.config.chinLength;
         this.jawMesh.position.z = basePosZ + this.config.chinForward;
         
         this.jawOutline.scale.y = this.jawMesh.scale.y * 1.05;
         this.jawOutline.position.z = this.jawMesh.position.z;

         if (this.torsoContainer) {
             this.torsoContainer.scale.set(this.config.torsoWidth, this.config.torsoHeight, this.config.torsoWidth);
         }
         
         this.rightArm.scale.setScalar(this.config.armScale);
         this.leftArm.scale.setScalar(this.config.armScale);

         this.rightThigh.scale.setScalar(this.config.legScale);
         this.leftThigh.scale.setScalar(this.config.legScale);

         for(let grp of this.heelGroups) {
             grp.scale.setScalar(this.config.heelScale);
             grp.scale.y *= this.config.heelHeight;
         }
         
         for(let grp of this.forefootGroups) {
             grp.scale.set(this.config.footWidth, 1, this.config.footLength);
         }

         if(this.toeUnits.length === 10) { 
             this.toeUnits.forEach((unit, idx) => {
                 const i = idx % 5;
                 const xBase = (i - 2) * 0.035;
                 unit.position.x = xBase * this.config.toeSpread;
             });
         }
         
         if(this.skinMaterial) this.skinMaterial.color.set(this.config.skinColor);
         
         // Eye Colors
         if(this.scleraMaterial) this.scleraMaterial.color.set(this.config.scleraColor);
         if(this.irisMaterial) this.irisMaterial.color.set(this.config.eyeColor);
         if(this.pupilMaterial) this.pupilMaterial.color.set(this.config.pupilColor);
         if(this.lipMaterial) this.lipMaterial.color.set(this.config.lipColor);

         // Eye Scaling
         for (const iris of this.irises) {
             iris.scale.setScalar(this.config.irisScale);
         }
         for (const pupil of this.pupils) {
             pupil.scale.setScalar(this.config.pupilScale);
         }

         // Fix for naked outfit dynamic skin color
         if (this.config.outfit === 'naked') {
             this.shirtMaterial.color.set(this.config.skinColor);
             this.pantsMaterial.color.set(this.config.skinColor);
             this.bootsMaterial.color.set(this.config.skinColor);
         }

         if (this.lastBodyType !== this.config.bodyType) {
             this.chest.visible = (this.config.bodyType === 'female');
             this.lastBodyType = this.config.bodyType;
         }
    }
    
    update(dt: number, input: PlayerInput, cameraAngle: number, obstacles: THREE.Object3D[]) {
        this.updateConfig();

        // Handle Triggers
        if (input.interact) this.playInteract();
        if (input.attack1) this.playPunch();
        if (input.attack2) this.playAxeSwing();

        // Handle Death Toggle
        if (input.isDead && !this.wasDeadKeyPressed) {
            this.isDead = !this.isDead;
            if (this.isDead) {
                this.soundManager.playDeath();
                this.deathTime = 0; // Reset animation timer
                this.deathVariation = {
                    side: Math.random() > 0.5 ? 1 : -1,
                    twist: (Math.random() - 0.5) * 0.5,
                    fallDir: Math.random() > 0.5 ? 1 : -1,
                    stumbleDir: (Math.random() - 0.5) * 0.5
                };
            } else {
                // Reset State
                this.isDead = false;
                this.mesh.rotation.set(0, this.mesh.rotation.y, 0); // Preserve Y facing
                this.mesh.position.y = 0;
                
                // Reset Limbs to default upright pose
                this.hips.position.y = 1.0;
                this.hips.rotation.set(0,0,0);
                this.head.rotation.set(0,0,0);
                this.rightArm.rotation.set(0,0,0);
                this.leftArm.rotation.set(0,0,0);
                this.rightThigh.rotation.set(0,0,0);
                this.leftThigh.rotation.set(0,0,0);
                this.rightShin.rotation.set(0,0,0);
                this.leftShin.rotation.set(0,0,0);
                this.rightForeArm.rotation.set(0,0,0);
                this.leftForeArm.rotation.set(0,0,0);

                this.recoverTimer = 0.5;
            }
        }
        this.wasDeadKeyPressed = input.isDead;

        if (this.isDead) {
            this.deathTime += dt;
        }

        // Update Timers for new states
        if (this.isInteracting) {
            this.interactTimer += dt;
            if (this.interactTimer > 0.4) {
                this.isInteracting = false;
                this.interactTimer = 0;
            }
        }

        if (this.isAxeSwing) {
            this.axeSwingTimer += dt;
            if (this.axeSwingTimer > 0.45) {
                this.isAxeSwing = false;
                this.axeSwingTimer = 0;
            }
        }

        if (this.isPunch) {
            this.punchTimer += dt;
            if (this.punchTimer > 0.3) {
                this.isPunch = false;
                this.punchTimer = 0;
            }
        }

        if (input.isPickingUp && !this.isPickingUp) {
            this.isPickingUp = true;
            this.pickUpTime = 0; // Start at 0 per reference code
            this.soundManager.playPickup();
        }
        if (this.isPickingUp) {
            this.pickUpTime += dt;
            if (this.pickUpTime > 1.2) {
                this.isPickingUp = false;
                this.pickUpTime = 0;
            }
        }

        const isMoving = input.x !== 0 || input.y !== 0;
        const speed = input.isRunning ? this.moveSpeed * this.runMultiplier : this.moveSpeed;

        let dx = 0;
        let dz = 0;

        if (isMoving && !this.isDead) {
            const angle = Math.atan2(input.x, input.y) + cameraAngle;
            dx = Math.sin(angle) * speed * dt;
            dz = Math.cos(angle) * speed * dt;

            let rotDiff = angle - this.mesh.rotation.y;
            while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
            while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
            this.mesh.rotation.y += rotDiff * this.turnSpeed * dt;

            // this.walkTime is handled inside animateVisuals now via delta
        }

        // Gravity
        if (this.isJumping) {
            this.jumpVelocity += this.gravity * dt;
            this.mesh.position.y += this.jumpVelocity * dt;
            if (this.mesh.position.y <= 0) {
                this.mesh.position.y = 0;
                this.isJumping = false;
                this.jumpVelocity = 0;
                this.soundManager.playLand();
            }
            this.jumpTimer += dt;
        } else {
            if (input.jump && !this.isPickingUp && !this.isDead) {
                this.isJumping = true;
                this.jumpVelocity = this.jumpPower;
                this.jumpTimer = 0;
                this.soundManager.playJump();
            }
            // Simple ground clamp
            if (this.mesh.position.y > 0) {
                this.mesh.position.y += this.gravity * dt * dt; // Simple integration
                if (this.mesh.position.y < 0) this.mesh.position.y = 0;
            }
        }

        // Collision
        if ((dx !== 0 || dz !== 0) && !this.isDead) {
            const nextX = this.mesh.position.x + dx;
            const nextZ = this.mesh.position.z + dz;
            const playerBox = new THREE.Box3();
            const r = 0.25;
            playerBox.min.set(nextX - r, 0, nextZ - r);
            playerBox.max.set(nextX + r, 2, nextZ + r);

            let collided = false;
            for (const obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if (obsBox.intersectsBox(playerBox)) {
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                this.mesh.position.x += dx;
                this.mesh.position.z += dz;
            }
        }
        
        // Recover Timer logic
        if (this.recoverTimer > 0) this.recoverTimer -= dt;

        this.animateVisuals(dt, isMoving, input.isRunning);
    }

    animateVisuals(delta: number, isMoving: boolean, isRunning: boolean) {
        const d = delta || 0.016;
        
        const lerp = THREE.MathUtils.lerp;
        const damp = 10 * delta;
        const ragdollDamp = 5 * delta;

        if (this.isDragged || this.recoverTimer > 0) {
            // --- ENHANCED RAGDOLL / DRAG ANIMATION WITH GRAVITY ---
            const recoveryAlpha = this.isDragged ? 1.0 : (this.recoverTimer / 2.0);
            const t = Date.now() * 0.01;
            
            const dragVel = this._tempVec1.copy(this.dragVelocity);
            if (!this.isDragged) dragVel.multiplyScalar(recoveryAlpha);

            const dragSpeed = dragVel.length() * 60;
            const invQuat = this._tempQuat.copy(this.mesh.quaternion).invert();
            const localDrag = dragVel.applyQuaternion(invQuat);
            const localDown = this._tempVec2.copy(this._localDown).applyQuaternion(invQuat);
            
            const noise = (freq: number) => Math.sin(t * freq);
            const limpness = 0.5 + Math.min(dragSpeed * 0.1, 1.5) * recoveryAlpha;
            const gravStr = 1.2 * recoveryAlpha; // Strength of gravity pull on limbs

            // Hips Position relative to "Anchor"
            let targetHipRotX = -localDrag.z * 1.5 + (localDown.z * gravStr * 0.5);
            let targetHipRotZ = localDrag.x * 1.5 - (localDown.x * gravStr * 0.5);
            let targetHipY = 0.9;

            if (this.isDragged) {
                if (this.draggedPartName === 'head') {
                    targetHipY = 0.5;
                    targetHipRotX += 0.8; 
                } else if (this.draggedPartName.includes('Arm')) {
                    targetHipRotZ += (this.draggedPartName === 'rightArm' ? 1.2 : -1.2);
                    targetHipY = 0.7;
                } else if (this.draggedPartName.includes('Leg')) {
                    targetHipRotX = Math.PI - 0.5;
                    targetHipY = 1.4;
                }
            } else {
                targetHipY = 1.0;
                targetHipRotX = 0;
                targetHipRotZ = 0;
            }

            this.hips.rotation.x = lerp(this.hips.rotation.x, targetHipRotX, ragdollDamp);
            this.hips.rotation.z = lerp(this.hips.rotation.z, targetHipRotZ, ragdollDamp);
            this.hips.position.y = lerp(this.hips.position.y, (targetHipY + noise(5) * 0.05 * limpness) * SCALE_FACTOR, ragdollDamp);

            // Gravity-aware Limb Dangling
            const armHangX = localDown.z * gravStr * 2.0;
            const armHangZ = -localDown.x * gravStr * 2.0;
            const legHangX = localDown.z * gravStr * 1.5;

            this.head.rotation.x = lerp(this.head.rotation.x, armHangX + 0.3 + noise(3) * 0.2, ragdollDamp);
            this.head.rotation.z = lerp(this.head.rotation.z, armHangZ + noise(4) * 0.3, ragdollDamp);

            const outwardForce = Math.min(dragSpeed * 0.8, 1.5);
            this.leftArm.rotation.z = lerp(this.leftArm.rotation.z, 0.4 + outwardForce + armHangZ, ragdollDamp);
            this.rightArm.rotation.z = lerp(this.rightArm.rotation.z, -(0.4 + outwardForce - armHangZ), ragdollDamp);
            
            this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, -localDrag.z * 4.0 + armHangX, ragdollDamp);
            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, -localDrag.z * 4.0 + armHangX, ragdollDamp);
            
            const legTrail = localDrag.z * 2.0;
            this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, 0.2 - legTrail + legHangX, ragdollDamp);
            this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, 0.1 - legTrail + legHangX, ragdollDamp);
            
            const shinBend = 0.5 + dragSpeed * 0.4 + Math.max(0, -localDown.y * gravStr);
            this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, shinBend, ragdollDamp);
            this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, shinBend * 0.8, ragdollDamp);

            this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, 0.8 * recoveryAlpha + localDown.z, ragdollDamp));
            this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, 0.8 * recoveryAlpha + localDown.z, ragdollDamp));

        } else if (this.isDead) {
            // --- REALISTIC SEQUENTIAL DEATH ANIMATION ---
            const dv = this.deathVariation || { side: 1, twist: 0, fallDir: 1, stumbleDir: 0 };
            const t = this.deathTime;
            
            const buckleEnd = 0.15;
            const fallEnd = 0.5;
            const impactStart = 0.45;
            const impactEnd = 0.8;
            const settleStart = 1.0;

            const buckleProgress = Math.min(t / buckleEnd, 1.0);
            const fallProgress = Math.min(Math.max(0, (t - buckleEnd) / (fallEnd - buckleEnd)), 1.0);
            const impactProgress = Math.min(Math.max(0, (t - impactStart) / (impactEnd - impactStart)), 1.0);
            
            const finalHipY = dv.fallDir === 1 ? 0.22 : 0.28;
            const collapseY = lerp(1.0, 0.7, buckleProgress);
            const fallingY = lerp(collapseY, finalHipY, fallProgress);
            
            const impactBounce = impactProgress < 1.0 ? Math.sin(impactProgress * Math.PI) * 0.12 * (1.0 - impactProgress) : 0;
            this.hips.position.y = lerp(this.hips.position.y, (fallingY + impactBounce) * SCALE_FACTOR, damp * 1.5);

            const targetRotX = (Math.PI / 2.05) * dv.fallDir * -1;
            const targetRotZ = dv.stumbleDir * 0.8;
            
            this.hips.rotation.x = lerp(this.hips.rotation.x, targetRotX * (buckleProgress * 0.2 + fallProgress * 0.8), damp);
            this.hips.rotation.z = lerp(this.hips.rotation.z, targetRotZ * fallProgress, damp);
            this.hips.rotation.y = lerp(this.hips.rotation.y, dv.twist * fallProgress, damp);

            const leftKnee = lerp(0, 1.4, buckleProgress) + lerp(0, -0.8, fallProgress);
            const rightKnee = lerp(0, 1.4, buckleProgress) + lerp(0, -0.4, fallProgress);
            this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, leftKnee, damp * 2);
            this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, rightKnee, damp * 2);

            const splayAmount = 0.5 * fallProgress;
            this.leftThigh.rotation.z = lerp(this.leftThigh.rotation.z, splayAmount, damp);
            this.rightThigh.rotation.z = lerp(this.rightThigh.rotation.z, -splayAmount, damp);
            this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, -0.3 * fallProgress, damp);

            const armOut = 1.2 * fallProgress;
            const armFlailX = dv.fallDir === 1 ? -1.0 : 1.5;
            
            this.leftArm.rotation.z = lerp(this.leftArm.rotation.x, armOut, damp);
            this.rightArm.rotation.z = lerp(this.rightArm.rotation.x, -armOut, damp);
            this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, armFlailX * fallProgress, damp);
            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, armFlailX * fallProgress, damp);

            const elbowFlop = 1.2 * impactProgress;
            this.leftForeArm.rotation.x = lerp(this.leftForeArm.rotation.x, -elbowFlop, damp);
            this.rightForeArm.rotation.x = lerp(this.rightForeArm.rotation.x, -elbowFlop, damp);

            const headSnap = buckleProgress * 0.4 * -dv.fallDir;
            const headFloorRot = (dv.fallDir === 1 ? 0.3 : -0.6) + (dv.side * 0.4);
            
            const currentHeadRotX = headSnap + (headFloorRot * impactProgress);
            this.head.rotation.x = lerp(this.head.rotation.x, currentHeadRotX, damp);
            this.head.rotation.z = lerp(this.head.rotation.z, dv.side * 0.5 * impactProgress, damp);

            this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, -0.4 * impactProgress, damp));
            this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, -0.4 * impactProgress, damp));

        } else if (this.isAxeSwing) {
            // --- WEAPON SWING ANIMATION ---
            const duration = 0.45;
            const p = this.axeSwingTimer / duration;
            let tArmX = 0, tArmZ = 0, tForeArmZ = 0, tTorsoY = 0, tHipsY = 1.0;

            if (p < 0.25) { // Wind-up
                const t = p / 0.25;
                tArmX = lerp(0, 0.6, t);
                tArmZ = lerp(0, -1.2, t);
                tForeArmZ = lerp(0, 0.4, t);
                tTorsoY = lerp(0, -0.6, t);
                tHipsY = 0.95;
            } else if (p < 0.65) { // Strike
                const t = (p - 0.25) / 0.4;
                tArmX = lerp(0.6, -1.2, t);
                tArmZ = lerp(-1.2, 1.3, t);
                tForeArmZ = lerp(0.4, -0.8, t);
                tTorsoY = lerp(-0.6, 0.9, t);
                tHipsY = 0.92;
            } else { // Recovery
                const t = (p - 0.65) / 0.35;
                tArmX = lerp(-1.2, 0, t);
                tArmZ = lerp(1.3, 0, t);
                tForeArmZ = lerp(-0.8, 0, t);
                tTorsoY = lerp(0.9, 0, t);
                tHipsY = lerp(0.92, 1.0, t);
            }

            const swingDamp = 25 * delta;
            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, tArmX, swingDamp);
            this.rightArm.rotation.z = lerp(this.rightArm.rotation.z, tArmZ, swingDamp);
            this.rightForeArm.rotation.z = lerp(this.rightForeArm.rotation.z, tForeArmZ, swingDamp);
            this.torsoContainer.rotation.y = lerp(this.torsoContainer.rotation.y, tTorsoY, swingDamp);
            this.hips.position.y = lerp(this.hips.position.y, tHipsY * SCALE_FACTOR, swingDamp);

        } else if (this.isPunch) {
            // --- PUNCH ANIMATION ---
            const duration = 0.3;
            const p = this.punchTimer / duration;
            let tArmX = 0, tTorsoY = 0;
            const punchDamp = 30 * delta;

            if (p < 0.2) { // Wind up
                tArmX = 0.5;
                tTorsoY = -0.2;
            } else if (p < 0.5) { // Thrust
                tArmX = -1.6;
                tTorsoY = 0.4;
            } else { // Return
                const t = (p - 0.5) / 0.5;
                tArmX = lerp(-1.6, 0, t);
                tTorsoY = lerp(0.4, 0, t);
            }

            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, tArmX, punchDamp);
            this.torsoContainer.rotation.y = lerp(this.torsoContainer.rotation.y, tTorsoY, punchDamp);

        } else if (this.isInteracting) {
            // --- INTERACT ANIMATION ---
            const p = Math.sin((this.interactTimer / 0.4) * Math.PI);
            this.head.rotation.x = lerp(this.head.rotation.x, p * 0.5, damp * 3);
            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, -p * 1.2, damp * 2);

        } else if (this.isPickingUp) {
            // --- PICK UP ANIMATION ---
            const duration = 1.2;
            const progress = (this.pickUpTime || 0) / duration;
            const bendFactor = Math.sin(progress * Math.PI); 

            this.hips.position.y = lerp(this.hips.position.y, (1.0 - bendFactor * 0.4) * SCALE_FACTOR, damp * 2);
            this.hips.position.z = lerp(this.hips.position.z, -bendFactor * 0.3 * SCALE_FACTOR, damp * 2);
            
            const torsoLean = bendFactor * 1.5;
            this.hips.rotation.x = lerp(this.hips.rotation.x, torsoLean, damp * 2);
            
            const thighRotation = -torsoLean - (bendFactor * 0.2);
            this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, thighRotation, damp * 2);
            this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, thighRotation, damp * 2);
            
            const shinRotation = bendFactor * 1.8;
            this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, shinRotation, damp * 2);
            this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, shinRotation, damp * 2);

            const currentTotalRot = torsoLean + thighRotation + shinRotation;
            const footCorrection = -currentTotalRot + (bendFactor * 0.25); 
            
            this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, footCorrection, damp * 2));
            this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, footCorrection, damp * 2));

            this.leftThigh.rotation.z = lerp(this.leftThigh.rotation.z, 0.2, damp * 2);
            this.rightThigh.rotation.z = lerp(this.rightThigh.rotation.z, -0.2, damp * 2);
            this.leftShin.rotation.z = lerp(this.leftShin.rotation.z, -0.2, damp * 2);
            this.rightShin.rotation.z = lerp(this.rightShin.rotation.z, 0.2, damp * 2);

            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, -bendFactor * 2.5, damp * 2);
            this.rightForeArm.rotation.x = lerp(this.rightForeArm.rotation.x, -bendFactor * 0.2, damp * 2);
            
            this.head.rotation.x = lerp(this.head.rotation.x, 0.6, damp * 2);
            this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, bendFactor * 0.7, damp * 2);

        } else if (this.isLedgeGrabbing) {
            // --- LEDGE CLIMB ANIMATION ---
            const duration = 0.9;
            const t = this.ledgeGrabTime / duration;
            
            const isHanging = t < 0.3;
            const isPulling = t >= 0.3 && t < 0.7;
            const isVaulting = t >= 0.7;

            if (isHanging) {
                this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, -2.8, damp * 2);
                this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, -2.8, damp * 2);
                this.leftForeArm.rotation.x = lerp(this.leftForeArm.rotation.x, -0.2, damp * 2);
                this.rightForeArm.rotation.x = lerp(this.rightForeArm.rotation.x, -0.2, damp * 2);
                
                this.hips.rotation.x = lerp(this.hips.rotation.x, 0.1, damp * 2);
                this.head.rotation.x = lerp(this.head.rotation.x, -0.5, damp * 2); 
                
                this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, 0.2, damp * 2);
                this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, 0.1, damp * 2);
            } else if (isPulling) {
                const subT = (t - 0.3) / 0.4;
                this.leftArm.rotation.x = lerp(-2.8, -1.5, subT);
                this.rightArm.rotation.x = lerp(-2.8, -1.5, subT);
                this.leftForeArm.rotation.x = lerp(-0.2, -2.2, subT);
                this.rightForeArm.rotation.x = lerp(-0.2, -2.2, subT);
                
                this.hips.rotation.x = lerp(0.1, 0.6, subT);
                this.head.rotation.x = lerp(-0.5, 0.2, subT); 
                
                this.leftThigh.rotation.x = lerp(0.2, -1.2, subT);
                this.leftShin.rotation.x = lerp(0.2, 1.5, subT);
                this.rightThigh.rotation.x = lerp(0.1, 0.4, subT);
            } else if (isVaulting) {
                const subT = (t - 0.7) / 0.3;
                this.leftArm.rotation.x = lerp(-1.5, 0.5, subT);
                this.rightArm.rotation.x = lerp(-1.5, 0.5, subT);
                this.leftForeArm.rotation.x = lerp(-2.2, -0.2, subT);
                this.rightForeArm.rotation.x = lerp(-2.2, -0.2, subT);

                this.leftThigh.rotation.x = lerp(-1.2, 0.2, subT);
                this.rightThigh.rotation.x = lerp(0.4, -0.8, subT);
                this.rightShin.rotation.x = lerp(0.1, 1.2, subT);
                
                this.hips.rotation.x = lerp(0.6, 0, subT);
            }

        } else if (this.isJumping) {
            // --- JUMP/FALL ANIMATION ---
            const airTime = this.jumpTimer || 0;
            // Only show jump/fall animation if we've been in the air long enough
            const showJumpAnim = airTime > 0.15;

            if (showJumpAnim) {
                if (this.jumpPhase === 'anticipation') {
                    const jumpProgress = Math.min(airTime / 0.15, 1.0);
                    const crouch = Math.sin(jumpProgress * Math.PI * 0.5) * 0.4;
                    
                    this.hips.position.y = lerp(this.hips.position.y, (1.0 - crouch) * SCALE_FACTOR, damp * 2);
                    this.hips.rotation.x = lerp(this.hips.rotation.x, crouch * 0.5, damp * 2);
                    
                    this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, -crouch * 2, damp * 2);
                    this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, -crouch * 2, damp * 2);
                    this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, crouch * 3, damp * 2);
                    this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, crouch * 3, damp * 2);
                    
                    this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, 1.2 * crouch, damp * 2);
                    this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, 1.2 * crouch, damp * 2);
                } else {
                    this.hips.rotation.x = lerp(this.hips.rotation.x, isMoving ? 0.2 : 0, damp);
                    const airborneTime = airTime - 0.15;
                    const extensionFactor = Math.max(0, 1.0 - airborneTime * 8);
                    const tuck = this.jumpVelocity > 0 ? 0.8 : 0.3;
                    const finalThighX = lerp(-tuck, 0.1, extensionFactor);
                    const finalShinX = lerp(tuck * 1.5, -0.1, extensionFactor);

                    this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, finalThighX, damp);
                    this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, finalThighX, damp);
                    this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, finalShinX, damp);
                    this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, finalShinX, damp);

                    const armFlail = this.jumpVelocity > 0 ? -1.0 : 0.5;
                    this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, armFlail, damp);
                    this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, armFlail, damp);
                    
                    this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, 0.5, damp));
                    this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, 0.5, damp));
                }
            } else if (isMoving) {
                // Keep playing walk/run animation during the brief airtime threshold
                this._animateMovement(delta, isRunning, damp, SCALE_FACTOR);
            }

        } else if (isMoving) {
            this._animateMovement(delta, isRunning, damp, SCALE_FACTOR);
        } else {
            // Idle Pose
            this.hips.position.y = lerp(this.hips.position.y, 1.0 * SCALE_FACTOR, damp);
            this.hips.position.z = lerp(this.hips.position.z, 0, damp);
            this.hips.rotation.x = lerp(this.hips.rotation.x, 0, damp);
            this.hips.rotation.y = lerp(this.hips.rotation.y, 0, damp);
            this.hips.rotation.z = lerp(this.hips.rotation.z, 0, damp);
            
            this.leftThigh.rotation.x = lerp(this.leftThigh.rotation.x, 0, damp);
            this.rightThigh.rotation.x = lerp(this.rightThigh.rotation.x, 0, damp);
            this.leftThigh.rotation.z = lerp(this.leftThigh.rotation.z, 0.15, damp);
            this.rightThigh.rotation.z = lerp(this.rightThigh.rotation.z, -0.15, damp);
            this.leftShin.rotation.z = lerp(this.leftShin.rotation.z, -0.15, damp);
            this.rightShin.rotation.z = lerp(this.rightShin.rotation.z, 0.15, damp);
            this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, 0, damp);
            this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, 0, damp);

            this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, 0, damp));
            this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, 0, damp));

            this.rightArm.rotation.x = lerp(this.rightArm.rotation.x, 0, damp);
            this.leftArm.rotation.x = lerp(this.leftArm.rotation.x, 0, damp);
            this.rightArm.rotation.z = lerp(this.rightArm.rotation.z, 0, damp);
            this.leftArm.rotation.z = lerp(this.leftArm.rotation.z, 0, damp);
            this.rightForeArm.rotation.x = lerp(this.rightForeArm.rotation.x, -0.2, damp);
            this.leftForeArm.rotation.x = lerp(this.leftForeArm.rotation.x, -0.2, damp);
            
            this.head.rotation.x = lerp(this.head.rotation.x, 0.12, damp);
            this.head.rotation.y = lerp(this.head.rotation.y, 0, damp);
            this.head.rotation.z = lerp(this.head.rotation.z, 0, damp);
        }
    }

    _animateMovement(delta: number, isRunning: boolean, damp: number, SCALE_FACTOR: number) {
        const lerp = THREE.MathUtils.lerp;
        const animSpeed = (isRunning ? 16 : 8);
        this.walkTime += delta * animSpeed;
        const t = this.walkTime;

        if (isRunning) {
            this.hips.rotation.x = lerp(this.hips.rotation.x, 0.4, damp);
            this.hips.position.z = lerp(this.hips.position.z, 0, damp);
            this.hips.position.y = (1.0 + Math.abs(Math.sin(t)) * 0.2) * SCALE_FACTOR;
            this.hips.rotation.y = Math.sin(t) * 0.15;
            this.hips.rotation.z = Math.sin(t) * 0.1;

            const thighSwing = 0.9;
            this.leftThigh.rotation.x = Math.sin(t + Math.PI) * thighSwing;
            this.rightThigh.rotation.x = Math.sin(t) * thighSwing;
            this.leftThigh.rotation.z = lerp(this.leftThigh.rotation.z, 0.15, damp);
            this.rightThigh.rotation.z = lerp(this.rightThigh.rotation.z, -0.15, damp);
            this.leftShin.rotation.z = lerp(this.leftShin.rotation.z, -0.15, damp);
            this.rightShin.rotation.z = lerp(this.rightShin.rotation.z, 0.15, damp);

            const kneeBendRun = 1.6;
            this.leftShin.rotation.x = Math.max(0, Math.cos(t)) * kneeBendRun + 0.3;
            this.rightShin.rotation.x = Math.max(0, -Math.cos(t)) * kneeBendRun + 0.3;

            const armSwingRun = 1.0;
            this.rightArm.rotation.x = Math.sin(t + Math.PI) * armSwingRun;
            this.leftArm.rotation.x = Math.sin(t) * armSwingRun;

            this.rightForeArm.rotation.x = -1.1 + Math.sin(t + Math.PI) * 0.3;
            this.leftForeArm.rotation.x = -1.1 + Math.sin(t) * 0.3;

            this.head.rotation.x = lerp(this.head.rotation.x, 0.25, damp);
            
        } else {
            this.hips.rotation.x = lerp(this.hips.rotation.x, 0, damp);
            this.hips.rotation.y = lerp(this.hips.rotation.y, 0, damp);
            this.hips.rotation.z = lerp(this.hips.rotation.z, 0, damp);
            this.hips.position.z = lerp(this.hips.position.z, 0, damp);
            this.hips.position.y = (1.0 + Math.sin(t * 2) * 0.05) * SCALE_FACTOR;

            this.leftThigh.rotation.x = Math.sin(t + Math.PI) * 0.5;
            this.rightThigh.rotation.x = Math.sin(t) * 0.5;
            this.leftThigh.rotation.z = lerp(this.leftThigh.rotation.z, 0.15, damp);
            this.rightThigh.rotation.z = lerp(this.rightThigh.rotation.z, -0.15, damp);
            this.leftShin.rotation.z = lerp(this.leftShin.rotation.z, -0.15, damp);
            this.rightShin.rotation.z = lerp(this.rightShin.rotation.z, 0.15, damp);
            this.leftShin.rotation.x = lerp(this.leftShin.rotation.x, 0, damp);
            this.rightShin.rotation.x = lerp(this.rightShin.rotation.x, 0, damp);

            const kneeBendWalk = 1.2;
            this.leftShin.rotation.x = Math.max(0, Math.cos(t)) * kneeBendWalk;
            this.rightShin.rotation.x = Math.max(0, -Math.cos(t)) * kneeBendWalk;

            this.rightArm.rotation.x = Math.sin(t + Math.PI) * 0.4;
            this.leftArm.rotation.x = Math.sin(t) * 0.4;

            this.rightForeArm.rotation.x = -Math.max(0, Math.cos(t)) * 0.5 - 0.2;
            this.leftForeArm.rotation.x = -Math.max(0, -Math.cos(t)) * 0.5 - 0.2;

            this.head.rotation.x = lerp(this.head.rotation.x, 0.15, damp);

            this.forefootGroups.forEach(fg => fg.rotation.x = lerp(fg.rotation.x, 0, damp));
            this.heelGroups.forEach(hg => hg.rotation.x = lerp(hg.rotation.x, 0, damp));
        }
    }
}